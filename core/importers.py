import pathlib
from typing import List
import zipfile
import json
import logging
import rich
from datetime import datetime

from .models import BlogArticlePage, BlogIndexPage

logger = logging.getLogger(__name__)


class MicroBlogImporter:
    """
    An import to take microblog .bar files, and
    import them into Wagtail, as BlogArticlePages
    """

    # extract .bar file to temporary dir, returning dir path
    def extract_bar_file(self, path_to_bar_file: str, target_dir: str) -> List:
        """
        Accept a path to a .bar file as generated by
        microblog, and a target directory, and return
        a path to a temporary directory containing
        the extracted files.
        """

        pth = pathlib.Path(target_dir)
        # unzip .bar file into target dir
        blog_archive = zipfile.ZipFile(path_to_bar_file)
        blog_archive.extractall(target_dir)

        return [file for file in pth.glob("*")]

    # read posts json file
    def fetch_posts(
        self, target_dir: str, path_to_feeds_file: str = "feed.json"
    ) -> List[dict]:
        """Parse the json, and return a list of posts to import"""

        json_path = pathlib.Path(target_dir / path_to_feeds_file)
        posts = json.load(open(json_path))

        return posts.get("items")

    # create post from item in posts file
    def create_blog_articles(self, posts: List) -> List[BlogArticlePage]:
        """
        Create a blog article page for each post, updating ones with
        the same timestamp
        """
        articles = []
        for post in posts:
            articles.append(self._create_blog_article(post))

        return articles

    def _create_blog_article(self, post: dict):
        """
        Accept a dict and create a blog post from it
        based on the title, date, content and tags
        """
        title = post.get("title")
        published_at = datetime.fromisoformat(post.get("date_published"))
        # add fallback
        if not title:
            title = published_at.strftime("Note at %Y-%m-%d:%H-%M")

        tags = post.get("tags")
        post_content = post.get("content_text")

        article = BlogArticlePage(
            title=title,
            published_at=published_at,
            # you need to present a JSON structure for a Streamfield
            content=json.dumps([{"type": "markdown", "value": post_content}]),
        )
        if tags:
            # we need to use the taggit API to add the tags
            article.tags.add(*tags)

        return article

    def add_articles_to_blog_index(self, articles):
        idx = BlogIndexPage.objects.first()
        for article in articles:
            idx.add_child(instance=article)
            idx.save()
            article.save()


# class WordpressBlogImporter:
# TODO: either implement this, or look at the new wagtail wordpress importer

#     def process_post(self, post):
#             logger.debug(post["content"]["rendered"])
#             logger.info(".")
#             try:
#                 page = BlogPage.objects.descendant_of(self.blog_index).get(
#                     slug=post["slug"]
#                 )
#             except BlogPage.DoesNotExist:
#                 page = BlogPage(slug=post["slug"])
#             page.title = self.convert_html_entities(post["title"]["rendered"])
#             page.body = post["content"]["rendered"]
#             if self.convert_images:
#                 page.body = self.create_images_from_urls_in_content(page.body)
#             page.search_description = self.convert_html_entities(
#                 post["excerpt"]["rendered"]
#             )
#             page.date = post["date"][:10]
#             self.set_blog_authors(page, post)
#             if self.convert_images:
#                 self.set_featured_media(page, post)
#             if page.id:
#                 page.save()
#             else:
#                 self.blog_index.add_child(instance=page)
#             self.set_categories(page, post)
#             self.set_tags(page, post)
#             page.save()  # Save is required after adding ParentalManyToManyField
